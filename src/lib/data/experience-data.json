{
    "work": [
        {
            "title": "Web Developer at CIRC",
            "timeperiod": "May 2021 - August 2023",
            "url": "https://www.southern.edu/academics/computing/circ.html",
            "description": "Responsibilities: In this company, I was a full stack developer in charge of creating web applications using primarily the Yii2 framework, which was written in PHP. Due to the architecture encouraged by this framework, I became very familiar with the MVC architecture. I also became very experienced with ORMs, RESTful APIs, several types of testing (unit, functional, and acceptance), and database management. Since the company used Apache as its server, I also became familiar with the basics of Apache. Some projects that I helped create when working with this company include a content authoring web app, a mission trip management app, and a game-based learning app. During my last months with this company, I worked with small prototypes that used Flutter as its front-end framework, so I'm experienced with the basics of cross-platform application development.",
            "technologies": [
                "HTML", "CSS", "JavaScript", "PHP", "JQuery", "Yii2", "MariaDB", "Apache", "Flutter", "Dart"
            ]
        }
    ],
    "project": [
        {
            "title": "CPU Scheduling Visualizer",
            "url": "https://joellv.github.io/cpu-virtualization/",
            "githubUrl": "https://github.com/JoelLV/cpu-virtualization",
            "description": "The purpose for this project was to help people understand how an operating system virtualizes its workload in order to create the illusion of multiple CPU's in a computer. This project accomplishes this goal by creating a simple visualization of how the CPU selects different processes over time. Currently, this project supports two types of policies: FIFO, and Round Robin. A graph is used to demonstrate how the CPU behaves according to the policy selected, and a table is also given in order for the user to specify basic information for each process. The project is easily expandable in order to support other policies. Implementing MLFQ, however, will be difficult to implement because more complex policies that require more advanced visuals such as this policy are out of scope for this project.",
            "technologies": [
                "HTML", "CSS", "Typescript", "ReactJS"
            ]
        },
        {
            "title": "Old Professional Portfolio",
            "url": null,
            "githubUrl": "https://github.com/JoelLV/project_portfolio",
            "description": "Outside of work, I used Flutter and Dart to build a personal web portfolio. Even though using Flutter for a basic web portfolio may seem overkill, I wanted to use it just because I wanted to explore its web capabilities. For my current web portfolio, I used Sveltekit.",
            "technologies": [
                "Flutter", "Dart"
            ]
        },
        {
            "title": "Current Professional Portfolio",
            "url": "https://www.joellv.com/",
            "githubUrl": "https://github.com/JoelLV/project-portfolio-v2",
            "description": "This project is my current professional portfolio where I display all my projects. This project was also my first exposure to the SvelteKit framework and TailwindCSS.",
            "technologies": [
                "JavaScript", "SvelteKit", "TailwindCSS"
            ]
        },
        {
            "title": "Nuclear Reactor Simulator",
            "url": null,
            "githubUrl": "https://github.com/JoelLV/ReactorSimulator",
            "description": "This was the final project for my Advanced Web Programming class. It was a group project that required us to use ReactJS along with the MaterialUI library. This project allows the user to manage the different nuclear reactors that are exposed via a RESTful API provided by the instructor. The project tracks the temperature of each reactor as well as the average temperature of all reactors, allows pins to descent and ascend to control the reactions of each reactor, allows toggling of cooling, and lastly, it gives the user the ability to name each reactor. All of this functionality is accomplished via API requests to the server provided by the instructor.",
            "technologies": [
                "HTML", "CSS", "JavaScript", "ReactJS"
            ]
        },
        {
            "title": "Dos Multiplayer Card Game",
            "url": null,
            "githubUrl": "https://github.com/JoelLV/multiplayer-dos-game",
            "description": "To explore the theory behind TCP sockets in Networking, I created an implementation of the famous game Dos created by Mattel. The frontend application and the backend application was written in C# with .NET 6. The frontend application has a very basic UI: a listbox to display the players in the lobby along with the number of cards that each have and another one to display the cards that the player has, a container to display the card that is currently at the center, and numerous buttons to submit cards, call Dos, finish turn, etc. The frontend was developed using WPF, while the backend was developed using only the standard library (no ASP.NET) because I wanted to learn and use TCP sockets. Compared to other personal projects I've created, this one is one of the biggest ones.",
            "technologies": [
                "C#", ".NET"
            ]
        },
        {
            "title": "Apartment Management App",
            "url": null,
            "githubUrl": "https://github.com/JoelLV/apartment-management-app-v1",
            "description": "This was my first C# application that I wrote. This project consists of a desktop application that is capable of managing apartments as well as the people that live in those apartments. The data is stored in a SQLite database in order to have access to the data even when offline. This project was also my first time that I worked with databases and ORMs. Though the UI is not as convenient as other apps out there, I was pretty happy that I was able to get it to work. The project follows the MVVM architecture and allows the user to see all the information stored in the tiny SQLite database through a datagrid. In this datagrid, the user can then add new data, modify existing data, and delete data by pressing the DELETE key.",
            "technologies": [
                "C#", ".NET", "SQLite"
            ]
        },
        {
            "title": "Backpacking Trip Planner API",
            "url": null,
            "githubUrl": "https://github.com/JoelLV/Backpacking-trip-planner-api/",
            "description": "This project was an introduction to the world of RESTful APIs, my favorite subject. In this project I learned to use NestJS and Typescript. This API allows users to plan backpacking trips. Users can add trails to the database, lodging locations, types of transportation to get to the trail, and gear sets that the user is going to bring to the trail. Once the user has specified all the necessary information for their next trip by using the different endpoints of the api, the user can now submit its finished trip to the database. The API also implements basic authentication (api key authentication) and makes good use of the mikro-orm library.",
            "technologies": [
                "Typescript", "NestJS", "MySql"
            ]
        },
        {
            "title": "Go Interpreter for Lox",
            "url": null,
            "githubUrl": "https://github.com/JoelLV/lox-go-interpreter",
            "description": "Using the guidelines provided by the book Crafting Interpreters, written by Robert Nystrom, I created an interpreter written in Go to interpret a made up language called Lox. The language is turing complete, dynamically typed, has a small standard library, and also has some extensions that the book does not go over, such as support for the integer type. Examples of the syntax can be found in the Tests folder of the project. This project was also my first project written in Go, and I really liked its simple, yet straightforward syntax. To see the book's website, go to: https://craftinginterpreters.com/. To interpret a lox script, the interpreter follows these steps. It first uses a scanner (or lexer) to turn the source code into an array tokens. These tokens can be either keywords, literals, or other characters reserved by the language, like parenthesis, double quotes, curly braces, etc. If this step is successful and no errors are found, the interpreter moves on to parsing the array of tokens that are provided by the scanner. The parser turns the array of tokens into an abstract syntax tree (AST) in order to handle operation precedence and also check correct syntax. If the parser does not find any syntax errors, the interpreter will use the AST provided by the parser to run the code.",
            "technologies": [
                "Golang"
            ]
        },
        {
            "title": "Python Interpreter for Lox",
            "url": null,
            "githubUrl": "https://github.com/JoelLV/Lox-Interpreter-Python",
            "description": "Very similar to the Go Interpreter, but instead of being written in Go, it was written in Python. This was the first version of the interpreter before moving on to another language that is faster. For more information regarding how the interpreter works, please see the description of the project \"Go Interpreter for Lox\". This interpreter was built using the guidelines provided by this book: https://craftinginterpreters.com/.",
            "technologies": [
                "Python"
            ]
        },
        {
            "title": "Simple Tracker",
            "url": null,
            "githubUrl": "https://github.com/JoelLV/simple-tracker",
            "description": "This project was my introduction to python and desktop GUIs. As the name suggests, the functions of this project is to track whatever data the user gives to the program, as long as this data can be mapped in a 2D plane. The user can create several trackers and describe its X and Y attributes. After configuring the tracker, the user can then add data to the tracker, modify it, delete it, as well as see the data in tabular form and graphical form. This project was done before I knew anything about databases, so in order to store this data persistently, all the data of each tracker was stored in a folder as text files, which were later parsed before the GUI was shown and changed when the user exited the GUI. This project uses the Pyside2 library to render GUI components.",
            "technologies": [
                "Python"
            ]
        }
    ]
}